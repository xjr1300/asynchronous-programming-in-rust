# 8. 非同期エコシステム

現在、Rustは非同期コードを記述するための基本的な機能のみを提供しています。
重要なことは、エグゼキューター、タスク、リアクター、コンビネーターそして低レベルなI/O機能とトレイトは、まだ標準ライブラリで提供されていません。
その間は、コミュニティが提供した非同期システムがこれらのギャップを埋めています。

非同期基盤チーム（The Async Foundations Team）は、複数のランタイムをカバーするために、非同期ブック（この本）にある例の拡張することに興味を持っています。
もし、このプロジェクトに貢献することに興味がある場合、[Zulip](https://rust-lang.zulipchat.com/#narrow/stream/201246-wg-async-foundations.2Fbook)で問い合わせてください。

## 非同期ランタイム

非同期ランタイムは、非同期アプリケーションを実行するために使用するライブラリです。
普通、ランタイムは、1つ以上の*エグゼキューター*と*リアクター*を一緒にまとめています。
リアクターは、非同期I/O、プロセス間通信やタイマーのような、外部イベントを購読する機構を提供します。
非同期ランタイムにおいて、サブスクライバーは、基本的に低レベルなI/O操作を表現したフューチャーです。
エグゼキューターは、タスクの実行とスケジューリングを処理します。
それらは実行中または待機中のタスクを追跡し続けて、完了に向けてポーリングして、それらが処理を進めることができるようになったときにタスクを目覚めさせます。
「エグゼキューター」という単語は、「ランタイム」と交換してよく使用されています。
ここで、「エコシステム」という単語を、互換性のあるトレイトと機能をまとめたランタイムを説明するために使用しています。

## コミュニティに提供された非同期クレート

### フューチャー・クレート

[futures](https://docs.rs/futures/)クレートは、非同期コードを記述するときに便利なトレイトと関数を含んでいます。
これは、`Stream`、`Sink`、`AsyncRead`と`AsyncWrite`トレイトとコンビネーターのようなユーティリティを含んでいます。
これらのユーティリティとトレイトは、最終的に標準ライブラリの一部になるかもしれません。

`futures`は独自のエグゼキューターを持ちますが、独自のリアクターを持っていないため、非同期I/Oまたはタイマー・フューチャーの実行をサポートしていません。
この理由で、それは完全なランタイムとして考えられていません。
一般的な選択は、他のクレートのエグゼキューターと`futures`のユーティリティを使用することです。

### 人気のある非同期ランタイム

標準ライブラリに非同期ランタイムが存在せず、公式が推奨するものはありません。
次のクレーとは人気のあるランタイムを提供します。

* [Tokio](https://docs.rs/tokio/): HTTP、gRPCそしてトレーシング・フレームwーアクを持つ人気のある非同期ランタイムです。
* [async-std](https://docs.rs/async-std/): 標準ライブラリのコンポーネントに対応する非同期コンポーネントを提供するクレートです。
* [smol](https://docs.rs/smol/): 小さく、単純な非同期ランタイムで、`UnixStream`または`TcpListener`のような構造体を包むために使用されます。
* [fuchsia-async](https://fuchsia.googlesource.com/fuchsia/+/master/src/lib/fuchsia-async/): Fuchsia OSで使用するエグゼキューターです。

## 互換性のあるエコシステムの決定

非同期アプリケーション、フレームワークそしてライブラリすべてが、互いに互換性があるわけではなく、またすべてのOSやプラットフォームで互換性があるわけではありません。
ほとんどの非同期コードは任意のエコシステムで使用できますが、いくつかのフレームワークとライブラリは、特定のエコシステムの使用を要求します。
エコシステムの制約は、常にドキュメント化されていませんが、どのライブラリ、トレイトまたは関数が依存する特定のエコシステムを決定する、経験則がいくつかあります。

非同期I/O、タイマー、プロセス間通信またはタスクと相互作用する非同期コードは、一般的に特定の非同期エグゼキューターとリアクターに依存しています。
非同期式、コンビネーター、同期型そしてストリームなど、他すべての非同期コードは、通常、エコシステムと独立して、エコシステムと独立した任意のネストしたフューチャーを提供しています。
プロジェクトを開始する前に、関連する非同期フレームワークとライブラリを調査して、選択したランタイムとの互換性とお互いの互換性を確認することを推奨します。

注目すべきことに、`Tokio`は`mio`リアクターを使用しており、それ独自の非同期I/Oトレイトのバージョンを定義して、`AsyncRead`と`AsyncWrite`を含んでいます。
単独では、`async-std`と`smol`に互換性がなく、それらは[async-executor](https://docs.rs/async-executor)クレートに依存しており、`AsyncRead`と`AsyncWrite`トレイトは`futures`に依存しています。

ランタイム要件の衝突は、あるランタイムように作成されたコードを、別のランタイム内で呼び出すことができる互換性レイヤによって解決できる可能性があります。
例えば、[async-compat](https://docs.rs/async_compat)クレートは、`Tokio`と他のランタイムの間の互換性レイヤを提供します。

非同期APIを公開しているライブラリは、タスクの生成したり、独自の非同期I/Oまたはタイマー・フューチャーを定義する必要がない限り、特定のエグゼキューターやリアクターに依存するべきではありません。
理想的には、バイナリのみが、スケジューリングやタスクの実行に責任を持つべきです。

## シングル・スレッドとマルチスレッドのエグゼキュター

非同期エグゼキューターは、シングル・スレッドまたはマルチ・スレッドになることができます。
例えば、`async-executor`クレートはシングル・スレッドの`LocalExecutor`とマルチ・スレッドの`Executor`を両方持っています。

マルチ・スレッドのエグゼキュターは、同時に複数のタスクを進めます。
それは、多くのタスクを持つワークロードの実行速度をとても向上することできますが、タスク間で同期するデータは通常より高価です。
シングルそしてマルチ・スレッドなランタイムを選択するとき、アプリケーションの性能を計測することをお勧めします。

タスクは、タスクを作成したスレッド上で、または分離したスレッド上のどちらかで実行されます。
非同期ランタイムは、よく分離したスレッド上にタスクを生成する機能を提供します。
タスクが分離したスレッド上で実行されている場合でも、それらはブロックされるべきではありません。
マルチ・スレッドのエグゼキューター上にタスクをスケジュールするためには、それらが`Send`でなくてはなりません。
いくつかのランタイムは、`Send`でないタスクを生成する関数を提供しており、すべてのタスクが、タスクを生成したスレッド上で実行されることを保証します。
また、いくつかのランタイムは、専用のスレッド上にブロッキング・タスクを生成する関数を提供しており、その関数は他のライブラリのブロックする同期コードをブロッキング実行するときに便利です。
